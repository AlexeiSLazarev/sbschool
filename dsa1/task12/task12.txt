Реализуйте на основе словаря новый класс NativeCache, который дополнительно будет учитывать количество обращений к
каждому ключу. Когда хэш-таблица заполняется и найти свободное место не удаётся, вытесняйте элемент с наименьшим
количеством обращений. Для этого в дополнение к self.values и self.slots заведите массив self.hits,
который будет хранить соответствующие количества обращений.

*Вытеснение элемента -- это просто удаление ключа и значения (освобождаем один слот каким-то внутренним способом).
Новый ключ может иметь другой хэш, и он должен механизмом разрешения коллизий попасть на освободившееся место.
Это не очень эффективная схема, тут сильно зависит от схемы разрешения коллизий, в данном учебном случае делаем так.
Но вы можете придумать какую-то свою схему.*

**`class** **NativeCache**:
    **def** **__init__**(self, sz):
        self.size = sz
        self.slots = [**None**] * self.size
        self.values = [**None**] * self.size
        self.hits = [**0**] * self.size`

Смоделируйте в тестах программно ситуацию, когда хэш-таблица заполнена (например, организуйте множество коллизий) и
проверьте, правильно ли работает схема вытеснения. Также проверяйте в тестах, корректно ли учитывается количество
обращений к ключам.